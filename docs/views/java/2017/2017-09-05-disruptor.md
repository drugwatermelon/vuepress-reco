---
layout:     post
title:      "disrupor 框架"
subtitle:   " know more do better "
date:       2020-08-07
author:     "zhairuihao"
header-img: "img/bt-java-1.jpg"
catalog:    false
categories:
    - Java
    - 源码分析
tags:
    - Java
    - 并发
---


<!--
Generated by NB Mind Map Plugin (https://github.com/raydac/netbeans-mmd-plugin)
2020-08-10
-->
# Disruptor
> Url: [https://ifeve\.com/disruptor/](https://ifeve.com/disruptor/)  

## 简介

### 它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。
> Url: [http://ifeve\.com/lmax](http://ifeve.com/lmax)  

## 本次内容基于 version

### com\.lmax:disruptor:3\.4\.2

## 概念

### 无锁设计<br/>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。

### 元素位置定位<br/>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。

### 环形数组结构<br/>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。

## 核心类

### RingBuffer

#### 结构

##### 环形数组\(数组内存连续\),存储事件\(数据\)Object\[\]

##### 维护 自增 sequence 来获取数据的索引 查找数据;\(seq%bufferSize\);<br/>实际是位运算达到取余的效果 类似hashMap 的索引计算

##### 对象数组实际大小 的前后都加了个BUFFER\_PAD \(4/8 一个对象应用的大小\)的空间

#### 读取

##### customer 通过 下一个要读取的位置 调用SequenceBarrier \# waitFor 获取最大可读取的序号;<br/>\(这里会执行WaitStrategy 等待策略\. \)<br/>通过获取的序列号轮休读取\(消费\)数据并更新消费的进度\(Cursored\);<br/>这里可以并发消费 不会有锁和竞争;<br/>

#### 写入

##### 单个生产者

###### 1. 两阶段提交 \(two\-phase commit\)

###### 1.1. 生产者需要申请 buffer 里的下一个节点\(更新 next\)

###### 1.1.1. Sequencer\.next

###### 1.1.1.1. 判断要写入的节点是否有消费者在消费,如果有就需要自旋等待

###### 1.2. 当生产者向节点写完数据，提交\(更新 Cursore\)。

##### 多个生产者

###### 1. 多生产者 会在提交的时候验证 cursore 必须是提交索引的前一个,才可以成功 否则自旋转

###### 2. 生产者在不同的时间完成数据写入，但是 Ring Buffer 的内容顺序总是会遵循 nextEntry\(\) 的初始调用顺序。也就是说，如果一个生产者在写入 Ring Buffer 的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。

<a name="173D66C1382A">
### Sequence

#### 通过顺序递增的序号来编号管理通过其进行交换的数据

#### 防止不同的 Sequence 之间的CPU缓存伪共享\(Flase Sharing\)问题。
*Related to: [伪共享](#173D66CF5EFA)*  

### Sequencer

#### 继承树

#####  ![alt 属性文本](http://resource.zhairuihao.show/blog/disruptor%E6%88%AA%E5%B1%8F2020-08-10%20%E4%B8%8A%E5%8D%8811.16.13.png)

#### 职责

##### 定义在生产者和消费者之间快速、正确地传递数据的并发算法。

##### 维护 ringbuffer 的索引获取 , 生产者需要先获取索引,才可以生产数据填入

##### 维护cursor\(游标sequence,即 最快生产者生产的的位置索引\), 提供读取方法
*Related to: [Sequence](#173D66C1382A)*  

##### 维护消费者消费索引数组,当生产者遇到消费者占用的索引时  执行等待策略 自旋,等消费者完成时 在返回给生产者

#### SingleProducerSequencer

#### MultiProducerSequencer

##### int\[\] availableBuffer

###### 1. 维护 ringbuffer的状态 是否可读,是否完成了写入

### SequenceBarrier

#### 获取发布后的的 ringBuffer sequence 序号

#### 状态变更提醒

#### 消费者等待策略 执行

### WaitStrategy

#### 消费者等待策略

### EventProcessor

#### 持有特定消费者\(Consumer\)的 Sequence，并提供用于调用事件处理实现的事件循环\(Event Loop\) 调用 EventHandler。

### EventHandler

#### 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现

### ConsumerRepository

#### 维护消费者调用链as :c 需要等待 a,c 完成后执行 \(a,c 的执行结果存储在 ringbuffer 中\)

## 补充

### 缓存行
<pre>&#32531;&#23384;&#26159;&#30001;&#32531;&#23384;&#34892;&#32452;&#25104;&#30340;&#65292;&#32531;&#23384;&#34892;&#26159;2&#30340;&#25972;&#25968;&#24130;&#20010;&#36830;&#32493;&#23383;&#33410;&#65292;&#19968;&#33324;&#20026;32-256&#20010;&#23383;&#33410;,
&#36890;&#24120;&#26159;64&#23383;&#33410;&#65292;&#24182;&#19988;&#23427;&#26377;&#25928;&#22320;&#24341;&#29992;&#20027;&#20869;&#23384;&#20013;&#30340;&#19968;&#22359;&#22320;&#22336;&#12290;
&#19968;&#20010;Java&#30340;long&#31867;&#22411;&#26159;8&#23383;&#33410;&#65292;&#22240;&#27492;&#22312;&#19968;&#20010;&#32531;&#23384;&#34892;&#20013;&#21487;&#20197;&#23384;8&#20010;long&#31867;&#22411;&#30340;&#21464;&#37327;&#12290;
&#23545;&#32531;&#23384;&#30340;&#25805;&#20316;&#36890;&#24120;&#26159;&#20197;&#19968;&#25972;&#20010;&#32531;&#23384;&#20026;&#21333;&#20301;&#36827;&#34892;&#30340;, &#25152;&#26377;&#19968;&#20010;&#20889;&#39057;&#32321;&#30340;&#21464;&#37327;&#29420;&#21344;&#19968;&#20010;&#32531;&#23384;&#34892;&#21487;&#20197;&#25552;&#39640;&#25928;&#29575;;
&#21487;&#20197;&#36890;&#36807;&#22635;&#20805;&#30340;&#26041;&#24335;&#21344;&#28385;&#19968;&#20010;&#32531;&#23384;&#34892;;
</pre>

<a name="173D66CF5EFA">
#### 伪共享

##### 如果两个独立的线程同时写两个不同的值\(内存地址相邻,在同一个缓存行上\)会更糟。<br/>因为每次线程对缓存行进行写操作时，<br/>每个内核都要把另一个内核上的缓存块无效掉并重新读取里面的数据。<br/>你基本上是遇到两个线程之间的写冲突了，尽管它们写入的是不同的变量。<br/>这就造成和缓存一直是失效的状态 就是伪共享的情况\.

#### 缓存行填充

##### 你会看到Disruptor消除这个问题，至少对于缓存行大小是64字节或更少的处理器架构来说是这样的<br/>（注：有可能处理器的缓存行是128字节，那么使用64字节填充还是会存在伪共享问题），<br/>通过增加补全\(6个 long \(6\*8\)\+ value\(1\*8\)\+对象头\(2 \*8字节\) = 64\)来确保ring buffer的序列号不会和其他东西同时存在于一个缓存行;<br/>因此没有伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。

#### Java内存布局

##### 对于HotSpot JVM，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位<br/>（如锁的状态或作为锁对象）组成的Mark Word。第二个字是对象所属类的引用。<br/>如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。
<pre>&#22240;&#27492;&#24403;&#23553;&#35013;&#23545;&#35937;&#30340;&#26102;&#20505;&#20026;&#20102;&#39640;&#25928;&#29575;&#65292;&#23545;&#35937;&#23383;&#27573;&#22768;&#26126;&#30340;&#39034;&#24207;&#20250;&#34987;&#37325;&#25490;&#24207;&#25104;&#19979;&#21015;&#22522;&#20110;&#23383;&#33410;&#22823;&#23567;&#30340;&#39034;&#24207;&#65306;

doubles (8) &#21644; longs (8)
ints (4) &#21644; floats (4)
shorts (2) &#21644; chars (2)
booleans (1) &#21644; bytes (1)
references (4/8)
&lt;&#23376;&#31867;&#23383;&#27573;&#37325;&#22797;&#19978;&#36848;&#39034;&#24207;&gt;</pre>

##### java实例数据\(各个成员变量\)

###### 1. boolean、byte = 1字节<br/>short 、char = 2字节<br/>int、float = 4字节<br/>long、double = 8字节<br/>引用类型 = 4/8字节\(不同位数的机器有所不同\)

### 内存屏障
<pre>&#23427;&#26159;&#19968;&#20010;CPU&#25351;&#20196;&#12290;&#22522;&#26412;&#19978;&#65292;&#23427;&#26159;&#36825;&#26679;&#19968;&#26465;&#25351;&#20196;&#65306;
     a)&#30830;&#20445;&#19968;&#20123;&#29305;&#23450;&#25805;&#20316;&#25191;&#34892;&#30340;&#39034;&#24207;&#65307; 
     b)&#24433;&#21709;&#19968;&#20123;&#25968;&#25454;&#30340;&#21487;&#35265;&#24615;(&#21487;&#33021;&#26159;&#26576;&#20123;&#25351;&#20196;&#25191;&#34892;&#21518;&#30340;&#32467;&#26524;)&#12290;


&#32534;&#35793;&#22120;&#21644;CPU&#21487;&#20197;&#22312;&#20445;&#35777;&#36755;&#20986;&#32467;&#26524;&#19968;&#26679;&#30340;&#24773;&#20917;&#19979;&#23545;&#25351;&#20196;&#37325;&#25490;&#24207;&#65292;
&#20351;&#24615;&#33021;&#24471;&#21040;&#20248;&#21270;&#12290;&#25554;&#20837;&#19968;&#20010;&#20869;&#23384;&#23631;&#38556;&#65292;&#30456;&#24403;&#20110;&#21578;&#35785;CPU&#21644;&#32534;&#35793;&#22120;&#20808;&#20110;&#36825;&#20010;&#21629;&#20196;&#30340;&#24517;&#39035;&#20808;&#25191;&#34892;&#65292;
&#21518;&#20110;&#36825;&#20010;&#21629;&#20196;&#30340;&#24517;&#39035;&#21518;&#25191;&#34892;&#12290;


&#20869;&#23384;&#23631;&#38556;&#21478;&#19968;&#20010;&#20316;&#29992;&#26159;&#24378;&#21046;&#26356;&#26032;&#19968;&#27425;&#19981;&#21516;CPU&#30340;&#32531;&#23384;&#12290;
&#20363;&#22914;&#65292;&#19968;&#20010;&#20889;&#23631;&#38556;&#20250;&#25226;&#36825;&#20010;&#23631;&#38556;&#21069;&#20889;&#20837;&#30340;&#25968;&#25454;&#21047;&#26032;&#21040;&#32531;&#23384;&#65292;
&#36825;&#26679;&#20219;&#20309;&#35797;&#22270;&#35835;&#21462;&#35813;&#25968;&#25454;&#30340;&#32447;&#31243;&#23558;&#24471;&#21040;&#26368;&#26032;&#20540;&#65292;
&#32780;&#19981;&#29992;&#32771;&#34385;&#21040;&#24213;&#26159;&#34987;&#21738;&#20010;cpu&#26680;&#24515;&#25110;&#32773;&#21738;&#39063;CPU&#25191;&#34892;&#30340;&#12290;</pre>

#### 和 java 的 关系volatile

##### 如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。

##### 写操作

###### 1. 1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。<br/><br/>2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，<br/>因为内存屏障会把之前的写入值都刷新到缓存。

##### 缺点

###### 1. 内存屏障的确是有开销的——编译器/cpu不能重排序指令，<br/>导致不可以尽可能地高效利用CPU，另外刷新缓存亦会有开销。
