---
title: Spring 事务传播
date: 2020-05-13
tags:
 - 代码
categories:
 - Java
 -  spring
---

## 事务传播行为类型	说明
TYPE | DESC
:----  | :----
PROPAGATION_REQUIRED | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
PROPAGATION_SUPPORTS | 支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY | 使用当前的事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEW | 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER | 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

## 事务的四种隔离级别

### 1、事务的四大特性（ACID）
    原子性
    操作要么全部成功，要么全部失败回滚。
    
    一致性
    事务执行前和执行后处于一致性状态。例如，转账前A、B共5000元，A、B之间转账后，两者之和仍应该是5000元。
    
    隔离性
    事务之间互不干扰。
    
    持久性
    事务一旦提交，数据的改变是永久性的，即使这时候数据库发生故障，数据也不会丢失。


### 2、与事务隔离级别的相关问题
    脏读
    A事务对一条记录进行修改，尚未提交，B事务已经看到了A的修改结果。若A发生回滚，B读到的数据就是错误的，这就是脏读。
    
    不可重复读
    A事务对一条记录进行修改，尚未提交，B事务第一次查询该记录，看到的是修改之后的结果，此时A发生回滚，B事务又一次查询该记录，看到的是回滚后的结果。同一个事务内，B两次查询结果不一致，这就是不可重复读。
    
    幻读
    A事务对所有记录进行修改，尚未提交，此时B事务创建了一条新记录，A、B都提交。A查看所有数据，发现有一条数据没有被修改，因为这是B事务新增的，就想看到了幻象一样，这就是幻读。


### 3、事务的隔离级别
    读未提交（read uncommitted）
    事务尚未提交，其他事务即可以看到该事务的修改结果。隔离级别最差，脏读、不可重复读、幻读都不能避免。
    
    读提交（read committed）
    事务只能看到其他事务提交之后的数据。可避免脏读，不可重复读、幻读无法避免。
    不可重复读原因：A事务修改，B事务查询，A提交前和提交后，B事务看到的数据是不一致的。
    幻读原因：A事务修改，B事务新增，B事务提交前，A事务已经提交。B事务提交后，A发现仍有数据未修改。
    
    可重复读（repeatable read）-------innodb默认隔离级别
    一个事务多次查询，无论其他事务对数据如何修改，看到的数据都是一致的。因为A事务查询数据时，若B同时在修改数据，A事务看到的永远是B事务执行前的数据。只有当A提交或者回滚之后，看到的才是最新的被B修改知乎的数据。可避免脏读、不可重复读，幻读无法避免。
    
    序列化（serializable）
    事务顺序执行，可避免脏读、不可重复读、幻读，但效率最差。因为A事务执行时，其他事务必须等待。